# Project Inviter: Architectural Context & Recent Evolution

**Version: 1.0**
**Last Updated:** 2025-08-09

**PURPOSE:** This document provides a comprehensive narrative of the Inviter application's database architecture, focusing on the evolution of its data access patterns. Its goal is to give any developer or AI agent the full context required to understand the system's current state, the rationale behind its design, and its history.

---

## 1. Core Database Philosophy: The Pointer Pattern

The system's database is a single DynamoDB table (`InviterTable`) built on a performance-critical pattern of **Canonical Records** and **Pointer Records**.

*   **Canonical Record:** The single source of truth for an entity. For example, the full data for a hangout event is stored in a single `Hangout` item, keyed with `PK = EVENT#{hangoutId}`.
*   **Pointer Record:** A denormalized, lightweight summary of a canonical record. For example, a `HangoutPointer` contains just enough information about a hangout (title, time, location name) to be displayed in a list. These pointers are the key to performant reads.

**The Golden Rule:** List views (like a group's feed of hangouts) **MUST** be generated by querying these pointer records. They **MUST NOT** be generated by querying a list of IDs and then fetching the full detail for each one (the N+1 anti-pattern).

---

## 2. The GSI Conflict: A History

The recent architectural changes revolved around fixing performance issues and inconsistencies related to Global Secondary Indexes (GSIs).

### 2.1. The Initial State & The "Fuzzy Time" Plan

The application had an existing GSI, `UserGroupIndex`, used to find the groups a user belongs to. A new feature, "Fuzzy Time," required a new, efficient way to query for a user's upcoming hangouts across all their groups, sorted by time.

The original plan (`FUZZY_TIME_IMPLEMENTATION_PLAN.md`) called for the creation of a **new GSI named `EntityTimeIndex`**. This index was intended to use a string-based sort key (e.g., `T#{timestamp}`).

### 2.2. The Conflict & Investigation

An investigation (`DB_investigation.md`) revealed several critical issues:

1.  The `EntityTimeIndex` was **never actually created** in the production environment.
2.  There was a **case-sensitivity conflict** in the database. Some items used a lowercase `gsi1pk` attribute (for the `UserGroupIndex`), while attempts to implement the new feature had created items with an uppercase `GSI1PK` attribute.
3.  The application was suffering from performance issues due to these inconsistencies and other parts of the code performing full table scans.

---

## 3. The Refactoring Journey: Migrating to a Correct Architecture

A multi-phase effort was undertaken to resolve these issues and implement a robust, performant solution for time-based queries.

### 3.1. The New GSI Strategy

A key architectural decision was made:

*   **Create a new `EntityTimeIndex` GSI**, as originally planned.
*   **Improve the design:** Instead of a string-based sort key, the GSI would use the existing `startTimestamp` attribute (Type: `Number`) as its sort key. This allows for more efficient, purely numeric time-range queries.
*   **Standardize the Partition Key:** The GSI would use the lowercase `gsi1pk` attribute as its partition key, consistent with the rest of the application (`BaseItem.java`).

**Final `EntityTimeIndex` Schema:**
*   **Partition Key:** `gsi1pk` (String)
*   **Sort Key:** `startTimestamp` (Number)

### 3.2. The Zero-Downtime Data Migration

To resolve the `gsi1pk` vs. `GSI1PK` conflict without taking the application offline, a multi-phase migration was executed:

1.  **Expand:** A version of the application was deployed that wrote to **both** `gsi1pk` and `GSI1PK` to ensure data consistency during the transition.
2.  **Backfill:** A migration script was run to scan the table and copy the value from any existing `GSI1PK` attributes into the new `gsi1pk` attribute. At the end of this phase, all relevant items were guaranteed to have the correct lowercase `gsi1pk` attribute.
3.  **Contract:** The final application code was deployed. This code reads from and writes to **only** the lowercase `gsi1pk` attribute and queries the new, correctly configured `EntityTimeIndex`.
4.  **Cleanup (Pending):** A final script to remove the now-redundant uppercase `GSI1PK` attribute from the table is recommended.

### 3.3. Key Code Implementation Rationale

Several key changes were made to the code:

*   **`@DynamoDbSubtypes` on `BaseItem.java`:** The root cause of the broken `/feed` endpoint was a deserialization issue. The DynamoDB Enhanced Client did not know that `HangoutPointer` was a valid subtype of `BaseItem`. Adding this annotation registered all the subclasses and fixed the issue, allowing the `instanceof HangoutPointer` check to pass.

*   **`@Override` on `getGsi1pk()` in `HangoutPointer.java`:** To associate the `HangoutPointer` with both the `UserGroupIndex` and the new `EntityTimeIndex`, the `getGsi1pk()` method was overridden in the `HangoutPointer` subclass. This was chosen over modifying `BaseItem` directly to maintain a clean abstraction; `BaseItem` remains generic, while the `HangoutPointer` class specifically declares which indexes it belongs to.

*   **Refactoring `findUpcomingHangoutsForParticipant`:** This method in `HangoutRepository` was refactored to be type-safe. The method signature was simplified to take only the `participantKey`, and the query logic was updated to use the numeric `startTimestamp` for the sort key condition.

---

## 4. Current State & Key Code Paths

It is critical to understand that there are now two different code paths for fetching hangouts.

*   **Path 1: Group Feed (Legacy)**
    *   **Endpoint:** `GET /groups/{groupId}/feed`
    *   **Flow:** `GroupController` -> `GroupService` -> `PolymorphicGroupRepositoryImpl.findHangoutsByGroupId()`
    *   **Mechanism:** Queries the **main table** where `PK = GROUP#{groupId}` and the sort key begins with `HANGOUT#`. This path is less efficient for complex use cases but functional for a single group's feed.

*   **Path 2: User-Centric Hangout List (New & Preferred)**
    *   **Endpoint:** (e.g., `/users/{id}/hangouts` - wired to the service method below)
    *   **Flow:** `HangoutServiceImpl.getHangoutsForUser()` -> `HangoutRepositoryImpl.findUpcomingHangoutsForParticipant()`
    *   **Mechanism:** Queries the new **`EntityTimeIndex` GSI**. This is the more powerful and efficient method for getting a user's complete, time-sorted list of events.

---

## 5. Pending Technical Debt & Future Work

1.  **Run the Cleanup Script:** The final migration phase, removing the old `GSI1PK` attribute, should be completed.
2.  **Address `EventRepository.findAll()`:** The original investigation noted that this method performs a table scan. It should be refactored or removed.
3.  **Add Integration Tests:** A robust suite of integration tests should be added to validate the behavior of the `EntityTimeIndex` query path to prevent future regressions.

---

## 6. Addendum: Interest / Attendance API Design

As of 2025-08-09, a plan was finalized to add endpoints for managing user attendance.

*   **API Endpoints:** `PUT /hangouts/{hangoutId}/interest` and `DELETE /hangouts/{hangoutId}/interest` were chosen to remain consistent with the underlying `InterestLevel` data model.
*   **Data Model:** The operation creates/updates/deletes an `InterestLevel` item with `PK = EVENT#{hangoutId}` and `SK = ATTENDANCE#{userId}`.

*   **Critical Implementation Detail (Atomic Counters):** A key requirement of this feature is to keep the `participantCount` on all `HangoutPointer` records consistent. The implementation requires a new repository method, `atomicallyUpdateParticipantCount`, which uses a DynamoDB `UpdateExpression` (`SET participantCount = if_not_exists(participantCount, :zero) + :delta`) to safely increment and decrement the count. This prevents race conditions and ensures the denormalized data in the pointer records remains accurate.